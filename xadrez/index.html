<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Xadrez Pantanal — vs IA</title>
  <style>
    :root{
      --bg:#0f1112;
      --panel:#111212;
      --accent:#b98a3d; /* tom dourado clássico */
      --muted:#aab7c6;
      --card:#0b0d0e;
      --board-size: min(84vmin,760px);
      --sq: calc(var(--board-size) / 8);
      --wood-light:#e6d5b8;
      --wood-dark:#b58b61;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      background: linear-gradient(180deg,var(--bg), #071017 80%);
      font-family: "Cormorant Garamond", Georgia, serif;
      color:#e9eef7;
      padding:24px;
    }

    .app{
      width:min(1180px,98%);
      display:grid;
      grid-template-columns: 1fr 340px;
      gap:22px;
      align-items:start;
    }

    header{
      grid-column:1/-1;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
      margin-bottom:6px;
    }
    h1{ font-size:20px; margin:0; color:var(--accent); letter-spacing:0.4px }
    .subtitle{ color:var(--muted); font-size:13px }

    /* board card */
    .board-card{
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border-radius:12px;
      padding:18px;
      display:flex;
      flex-direction:column;
      gap:12px;
      align-items:center;
      box-shadow: 0 10px 30px rgba(2,6,23,0.7);
    }

    /* board container using your image as background */
    #board {
      position: relative;
      width: var(--board-size);
      height: var(--board-size);
      border-radius:8px;
      overflow:hidden;
      background-image: url("tabuleirotchetche.png"); /* <--- coloque sua imagem aqui */
      background-size: cover;
      background-position: center;
      border: 6px solid #49321f;
      box-shadow: 0 12px 30px rgba(0,0,0,0.6);
    }

    /* piece style (absolute positioning) */
    .piece {
      position: absolute;
      width: calc(var(--sq) * 0.96);
      height: calc(var(--sq) * 0.96);
      transform-origin: center center;
      transition: left 140ms ease, top 140ms ease, transform 120ms ease;
      user-select: none;
      cursor: pointer;
    }
    .piece.dragging{ transform: scale(1.08); opacity:0.95; z-index:999; cursor:grabbing }

    /* panel */
    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      padding:14px;
      border-radius:12px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .status{
      padding:10px;
      border-radius:8px;
      background: rgba(0,0,0,0.18);
      font-weight:700;
      color:#fff;
    }

    .controls{ display:flex; gap:8px; flex-wrap:wrap }
    .btn{
      background:linear-gradient(180deg,var(--accent), #f0c671);
      color:#07202a;
      padding:8px 12px;
      border-radius:8px;
      border: none;
      font-weight:700;
      cursor:pointer;
    }

    label{ font-size:13px; color:var(--muted) }
    input[type=range]{ width:100% }
    .moves{
      max-height:300px;
      overflow:auto;
      padding:8px;
      border-radius:8px;
      background: rgba(0,0,0,0.06);
      color:var(--muted);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      font-size:14px;
    }

    .footer-small{ font-size:12px; color:var(--muted) }

    @media(max-width:980px){
      .app{ grid-template-columns: 1fr; }
      .panel{ order:2; width:100% }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div>
        <h1>Xadrez Pantanal</h1>
        <div class="subtitle">Clássico · Limpo · vs Computador</div>
      </div>
      <div class="footer-small">Clique numa peça (ou arraste) para mover — promoção automática a rainha.</div>
    </header>

    <section class="board-card" aria-label="Tabuleiro">
      <div id="board" aria-hidden="false" role="application"></div>
    </section>

    <aside class="panel" aria-label="Painel lateral">
      <div>
        <div class="status" id="status">Carregando...</div>
      </div>

      <div>
        <label for="difficulty">Dificuldade (profundidade da IA): <span id="depthLabel">2</span></label>
        <input id="difficulty" type="range" min="1" max="4" value="2" />
      </div>

      <div class="controls">
        <button id="resetBtn" class="btn">Reiniciar</button>
        <button id="undoBtn" class="btn">Desfazer</button>
        <button id="flipBtn" class="btn">Virar Lados</button>
      </div>

      <div>
        <h3 style="margin:6px 0 6px 0">Histórico de Lances</h3>
        <div class="moves" id="moves"></div>
      </div>

      <div style="margin-top:6px" class="footer-small">Dica: rodar via Live Server ou `python -m http.server` para evitar bloqueios do navegador ao usar o motor.</div>
    </aside>
  </div>

  <!-- dependências -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/1.0.0/chess.min.js"></script>
  <!-- Stockfish: CDN que expõe STOCKFISH() (se houver problema troque pela sua build local) -->
  <script src="https://cdn.jsdelivr.net/gh/niklasf/stockfish.js/stockfish.js"></script>

  <script>
    /* ---------------------------
       CONFIGURAÇÕES (substitua imagens aqui)
       --------------------------- */
    // Coloque os nomes EXATOS dos seus arquivos de imagem na mesma pasta do HTML.
    const PIECE_IMAGES = {
      /* Brancos (maiúsculas no chess.js) */
      K: "rei_branco.png",
      Q: "rainha_branca.png",
      R: "torre_branca.png",
      B: "bispo_branco.png",
      N: "cavalo_branco.png",   // <--- troque pelo seu cavalo branco
      P: "peao_branco.png",
      /* Pretos (minúsculas no chess.js) */
      k: "rei_preto.png",
      q: "rainha_preta.png",
      r: "torre_preta.png",
      b: "bispo_preto.png",
      n: "cavalo_preto.png",    // <--- troque pelo seu cavalo preto
      p: "peao_preto.png"
    };

    /* ---------------------------
       Variáveis principais
       --------------------------- */
    const boardEl = document.getElementById("board");
    const statusEl = document.getElementById("status");
    const movesEl = document.getElementById("moves");
    const difficultyEl = document.getElementById("difficulty");
    const depthLabel = document.getElementById("depthLabel");
    const resetBtn = document.getElementById("resetBtn");
    const undoBtn = document.getElementById("undoBtn");
    const flipBtn = document.getElementById("flipBtn");

    const SQUARE = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--sq')) || (Math.min(window.innerWidth,800) / 8);
    // Will recalc dynamic square size based on board element
    function squareSize(){ return boardEl.clientWidth / 8; }

    const game = new Chess();
    let engine = null;
    let engineBusy = false;
    let playerColor = 'w'; // jogador humano (padrão: brancas)
    let dragging = null; // {el, piece, fromSquare, offsetX, offsetY}
    let boardOrientation = 'white'; // controls whether to flip coordinate mapping

    /* ---------------------------
       Inicialização do engine Stockfish
       --------------------------- */
    function initEngine(){
      try {
        engine = STOCKFISH();
      } catch (e) {
        console.error("Não foi possível inicializar Stockfish via CDN. Veja console.", e);
        statusEl.textContent = "Erro ao iniciar engine. Rode via servidor local e verifique console.";
        engine = null;
        return;
      }
      engine.onmessage = function(event){
        // algumas builds retornam strings, outras objetos; normalizar
        const data = (typeof event === "string") ? event : (event.data || "");
        handleEngineOutput(data);
      };
      // Warm-up
      engine.postMessage("uci");
    }

    // parse output
    let lastBestMove = null;
    function handleEngineOutput(line){
      if(!line) return;
      // procurar "bestmove e2e4"
      if(line.startsWith("bestmove")){
        const parts = line.split(" ");
        const best = parts[1];
        lastBestMove = best;
        if(best && best !== "(none)"){
          // aplicar movimento na posição real
          const from = best.slice(0,2);
          const to = best.slice(2,4);
          // promoção (se houver 5º caractere)
          const promo = best.length >= 5 ? best[4] : undefined;
          game.move({ from, to, promotion: promo || 'q' });
          refreshBoard();
          updateUI();
        }
        engineBusy = false;
      }
    }

    /* ---------------------------
       Renderização do tabuleiro e peças
       --------------------------- */
    function refreshBoard(){
      // limpa
      while(boardEl.firstChild) boardEl.removeChild(boardEl.firstChild);

      const board = game.board(); // array 8x8, r0 = rank8
      const size = squareSize();
      for(let r=0;r<8;r++){
        for(let c=0;c<8;c++){
          const piece = board[r][c];
          if(piece){
            const img = document.createElement("img");
            const key = piece.color === 'w' ? piece.type.toUpperCase() : piece.type.toLowerCase();
            img.src = PIECE_IMAGES[key];
            img.className = 'piece';
            img.draggable = false;
            // compute coordinates considering orientation
            let col = c, row = r;
            if(boardOrientation === 'white'){
              // chess.board() r=0 is rank8, so top-left = a8 -> we want column c, row r
            } else {
              // flip
              col = 7 - c;
              row = 7 - r;
            }
            img.style.left = (col * size) + 'px';
            img.style.top  = (row * size) + 'px';
            img.dataset.square = "abcdefgh"[c] + (8 - r); // square name in chess.js board coords
            boardEl.appendChild(img);
          }
        }
      }
    }

    // transforma coordenadas x,y (relativas ao boardEl) em notação (e2 etc)
    function coordsToSquare(x,y){
      const size = squareSize();
      let col = Math.floor(x / size);
      let row = Math.floor(y / size);
      if(boardOrientation === 'white'){
        // col 0 -> a, row 0 -> rank 8
        return "abcdefgh"[col] + (8 - row);
      } else {
        // flipped: col0 is h, row0 is rank1
        return "abcdefgh"[7 - col] + (1 + row);
      }
    }

    // centraliza peça visualmente numa casa
    function snapToSquare(el, square){
      const file = square.charCodeAt(0) - "a".charCodeAt(0);
      const rank = parseInt(square[1],10);
      // compute c,r (c=0..7 left to right in chess.board coords)
      const c = file;
      const r = 8 - rank;
      let col = c, row = r;
      if(boardOrientation === 'white'){
        // ok
      } else {
        col = 7 - c;
        row = 7 - r;
      }
      const size = squareSize();
      el.style.left = (col * size) + 'px';
      el.style.top  = (row * size) + 'px';
    }

    /* ---------------------------
       Interação: clique / arraste
       --------------------------- */
    boardEl.addEventListener('pointerdown', (ev) => {
      const target = ev.target;
      if(!target.classList.contains('piece')) return;
      // only allow user to move their color pieces
      const sq = target.dataset.square;
      const piece = game.get(sq);
      if(!piece || piece.color !== playerColor) return;

      ev.preventDefault();
      dragging = {
        el: target,
        from: sq,
        startX: ev.clientX,
        startY: ev.clientY,
        origLeft: parseFloat(target.style.left),
        origTop: parseFloat(target.style.top),
        offsetX: ev.clientX - target.getBoundingClientRect().left,
        offsetY: ev.clientY - target.getBoundingClientRect().top
      };
      target.classList.add('dragging');
      boardEl.setPointerCapture(ev.pointerId);
    });

    boardEl.addEventListener('pointermove', (ev) => {
      if(!dragging) return;
      ev.preventDefault();
      const rect = boardEl.getBoundingClientRect();
      const x = ev.clientX - rect.left - dragging.offsetX + (squareSize()/2);
      const y = ev.clientY - rect.top - dragging.offsetY + (squareSize()/2);
      // move element centered to pointer
      dragging.el.style.left = (ev.clientX - rect.left - dragging.offsetX) + 'px';
      dragging.el.style.top  = (ev.clientY - rect.top - dragging.offsetY) + 'px';
    });

    boardEl.addEventListener('pointerup', (ev) => {
      if(!dragging) return;
      boardEl.releasePointerCapture(ev.pointerId);
      dragging.el.classList.remove('dragging');
      const rect = boardEl.getBoundingClientRect();
      const x = ev.clientX - rect.left;
      const y = ev.clientY - rect.top;
      const toSquare = coordsToSquare(x,y);
      // try move
      const move = game.move({ from: dragging.from, to: toSquare, promotion: 'q' });
      if(!move){
        // snap back if illegal
        snapToSquare(dragging.el, dragging.from);
      } else {
        // legal move applied; redraw (captures are automatic by chess.js)
        refreshBoard();
        appendHistory();
        updateStatus();
        // IA plays after small delay
        setTimeout(() => { makeEngineMove(); }, 300);
      }
      dragging = null;
    });

    // also allow click-to-select + click-to-move
    let clickSelected = null;
    boardEl.addEventListener('click', (ev) => {
      const tgt = ev.target;
      const isPiece = tgt.classList && tgt.classList.contains('piece');
      const rect = boardEl.getBoundingClientRect();
      const x = ev.clientX - rect.left;
      const y = ev.clientY - rect.top;
      const square = coordsToSquare(x,y);

      if(isPiece){
        // select piece
        const piece = game.get(tgt.dataset.square);
        if(piece && piece.color === playerColor){
          clickSelected = tgt.dataset.square;
          // slight visual feedback
          tgt.style.transform = 'scale(1.06)';
          setTimeout(()=> tgt.style.transform = '', 220);
        }
      } else {
        // clicked empty square — if had selected, attempt move
        if(clickSelected){
          const mv = game.move({ from: clickSelected, to: square, promotion: 'q' });
          if(mv){
            refreshBoard();
            appendHistory();
            updateStatus();
            setTimeout(()=> makeEngineMove(), 300);
          }
          clickSelected = null;
        }
      }
    });

    /* ---------------------------
       UI: histórico, status, botões
       --------------------------- */
    function appendHistory(){
      const hist = game.history({ verbose: true });
      let html = '<ol style="margin:0;padding-left:18px">';
      for(let i=0;i<hist.length;i+=2){
        const num = Math.floor(i/2)+1;
        const w = hist[i] ? hist[i].san : '';
        const b = hist[i+1] ? hist[i+1].san : '';
        html += `<li style="margin-bottom:6px"><strong>${num}.</strong> ${w} ${b ? ' / ' + b : ''}</li>`;
      }
      html += '</ol>';
      movesEl.innerHTML = html;
      movesEl.scrollTop = movesEl.scrollHeight;
    }

    function updateStatus(){
      let s = '';
      if(game.in_checkmate()){
        s = `Xeque-mate — ${game.turn() === 'w' ? 'Pretas' : 'Brancas'} venceram.`;
      } else if(game.in_draw()){
        s = 'Empate.';
      } else {
        s = (game.turn() === 'w' ? 'Brancas' : 'Pretas') + ' jogam';
        if(game.in_check()) s += ' — Xeque!';
      }
      if(engineBusy) s = 'IA pensando...';
      statusEl.textContent = s;
    }

    resetBtn.addEventListener('click', () => {
      game.reset();
      refreshBoard();
      appendHistory();
      updateStatus();
      // if player is black, engine moves first
      if(playerColor === 'b'){
        setTimeout(()=> makeEngineMove(), 300);
      }
    });

    undoBtn.addEventListener('click', () => {
      // desfaz último par (IA+player) para manter consistência
      game.undo();
      game.undo();
      refreshBoard();
      appendHistory();
      updateStatus();
    });

    flipBtn.addEventListener('click', () => {
      boardOrientation = (boardOrientation === 'white') ? 'black' : 'white';
      // alterna jogador (opção: quem era branco vira preto). Aqui mantemos jogador humano sempre 'w' - se preferir, trocar lógica.
      refreshBoard();
    });

    difficultyEl.addEventListener('input', (e) => {
      depthLabel.textContent = e.target.value;
    });

    /* ---------------------------
       IA: chamada ao Stockfish
       --------------------------- */
    function makeEngineMove(){
      if(!engine) return;
      if(game.game_over()) { updateStatus(); return; }
      engineBusy = true;
      updateStatus();
      const depth = parseInt(difficultyEl.value,10) || 2;
      const fen = game.fen();
      engine.postMessage("position fen " + fen);
      engine.postMessage("go depth " + (depth * 2 + 2)); // multiplicamos pra maior busca (experiência prática)
      // output handled in handleEngineOutput
    }

    /* ---------------------------
       Inicialização
       --------------------------- */
    function start(){
      initEngine();
      refreshBoard();
      appendHistory();
      updateStatus();
      depthLabel.textContent = difficultyEl.value;
      // if player is black, let engine start
      if(playerColor === 'b'){
        setTimeout(()=> makeEngineMove(), 500);
      }
    }

    // reflow on resize to snap pieces positions
    window.addEventListener('resize', ()=> {
      refreshBoard();
    });

    // start
    start();

    /* ---------------------------
       Erros comuns / dicas
       --------------------------- 
       - Coloque todas as imagens listadas em PIECE_IMAGES na mesma pasta do HTML.
       - Rode via Live Server ou python -m http.server para que Stockfish carregue corretamente.
       - Se o motor não iniciar, verifique console (F12) para mensagens do STOCKFISH() CDN.
    --------------------------- */
  </script>
</body>
</html>
